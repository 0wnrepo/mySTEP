/* ObjC-2.0 scanner - based on http://www.lysator.liu.se/c/ANSI-C-grammar-l.html */
/* part of objc2pp - an obj-c 2 preprocessor */

	/* digit */
D			[0-9]
	/* letter */
L			[a-zA-Z_$]
	/* hex letter */
H			[a-fA-F0-9]
	/* exponent */
E			[Ee][+-]?{D}+
	/* float suffix */
FS			(f|F|l|L)
	/* int suffix */
IS			(u|U|l|L)*

%{
#include <stdio.h>
#include "y.tab.h"
#include "node.h"
	
#define error(X)
	
void charCount(void);
void comment(int cxx);

int column = 0;
int line = 1;	
	
struct RESERVED
	{
		char *word;
		int token;
	} reserved[]={
	"auto", AUTO, 
	"break", BREAK, 
	"case", CASE, 
	"char", CHAR, 
	"const", CONST, 
	"continue", CONTINUE, 
	"default", DEFAULT, 
	"do", DO, 
	"double", DOUBLE, 
	"else", ELSE, 
	"enum", ENUM, 
	"extern", EXTERN, 
	"float", FLOAT, 
	"for", FOR, 
	"goto", GOTO, 
	"if", IF, 
	"int", INT, 
	"long", LONG, 
	"register", REGISTER, 
	"return", RETURN, 
	"short", SHORT, 
	"signed", SIGNED, 
	"sizeof", SIZEOF, 
	"static", STATIC, 
	"struct", STRUCT, 
	"switch", SWITCH, 
	"typedef", TYPEDEF, 
	"union", UNION, 
	"unsigned", UNSIGNED, 
	"void", VOID, 
	"volatile", VOLATILE, 
	"while", WHILE, 

		/* operators - only used for reverse lookup since they are not keywords */
		
		"...", ELLIPSIS,
		">>=", RIGHT_ASSIGN,
		"<<=", LEFT_ASSIGN,
		"+=", ADD_ASSIGN,
		"-=", SUB_ASSIGN,
		"*=", MUL_ASSIGN,
		"/=", DIV_ASSIGN,
		"%=", MOD_ASSIGN,
		"&=", AND_ASSIGN,
		"^=", XOR_ASSIGN,
		"|=", OR_ASSIGN,
		">>", RIGHT_OP,
		"<<", LEFT_OP,
		"++", INC_OP,
		"--", DEC_OP,
		"->", PTR_OP,
		"&&", AND_OP,
		"||", OR_OP,
		"<=", LE_OP,
		">=", GE_OP,
		"==", EQ_OP,
		"!=", NE_OP,
		
	/* Obj-C 1.0 extensions */
	
	"@interface", AT_INTERFACE, 
	"@implementation", AT_IMPLEMENTATION, 
	"@end", AT_END, 
	"@class", AT_CLASS, 
	"@protocol", AT_PROTOCOL, 
	"@defs", AT_DEFS, 
	"@selector", AT_SELECTOR, 
	"@encode", AT_ENCODE, 
	"@protected", AT_PROTECTED, 
	"@private", AT_PRIVATE, 
	"@public", AT_PUBLIC,
		
	// FIXME: these are not really keywords!
	// it is 100% legal to write 'int id' or 'NSString *Class;'
	// they behave like preinitialized global typedefs that can be overwritten.
	// but aren't. I.e. typedef int SEL; int SEL; only gives an error on the second definition.
	// or typedef BOOL SEL; SEL x; defines x to be a BOOL
	// or 	int x, BOOL; BOOL *x; compiles fine
		
	"inout", INOUT, 
	"in", IN, 
	"out", OUT, 
	"byref", BYREF, 
	"bycopy", BYCOPY, 
	"oneway", ONEWAY, 
	
	"id", ID, 
	"SEL", SEL, 
	"BOOL", BOOL, 
	"unichar", UNICHAR, 
	"Class", CLASS, 
	
	/* Obj-C 2.0 extensions */
	
	"@try", AT_TRY, 
	"@catch", AT_CATCH, 
	"@finally", AT_FINALLY, 
	"@throw", AT_TRY, 
	"@synchronized", AT_SYNCHRONIZED, 

	/* Obj-C 1.5 extensions */
	
	"@property", AT_PROPERTY, 
	"@synthesize", AT_SYNTHESIZE, 
	"@optional", AT_OPTIONAL, 
	"@required", AT_REQUIRED, 
		// these two are real keywords and only allowed in type specifiers
	"__weak", WEAK, 
	"__strong", STRONG,
		
		
	};
	
int symtab;	/* global symbol table */
	
void scaninit(void)
	{
		int i;
		symtab=dictionary();
		for(i=0; i<sizeof(reserved)/sizeof(reserved[0]); i++)
			{ // initialize all reserved words in symbol table
			int n=lookup(symtab, reserved[i].word);
			setType(n, reserved[i].token);
			}
	}
	
%}

%%

"/*"			{ comment(0); }
"//"			{ comment(1); }
"# [0-9]* \".*\" [0-9]*" { /* handle */ }	/* try to ignore line markers generated by preprocessor */

	/* identifiers and keywords */

{L}({L}|{D})*  { 
	int s;
	charCount();
	s=lookup(symtab, yytext);
	if(type(s) == 0)
		setType(s, IDENTIFIER);	/* new entry */
	yylval=s;
	if(right(s))
		return TYPE_NAME;	/* typedef'd type name */
	return type(s);
} 

	/* numeral CONSTANTs */
0[xX]{H}+{IS}?		{ charCount(); yylval=cons(yytext); return(CONSTANT); }
0{D}+{IS}?			{ charCount(); yylval=cons(yytext); return(CONSTANT); }
{D}+{IS}?			{ charCount(); yylval=cons(yytext); return(CONSTANT); }
L?'(\\.|[^\\'])+'	{ charCount(); yylval=cons(yytext); return(CONSTANT); }

{D}+{E}{FS}?		{ charCount(); yylval=cons(yytext); return(CONSTANT); }
{D}*"."{D}+({E})?{FS}?	{ charCount(); yylval=cons(yytext); return(CONSTANT); }
{D}+"."{D}*({E})?{FS}?	{ charCount(); yylval=cons(yytext); return(CONSTANT); }

	/* string CONSTANTs */

L?\"(\\.|[^\\"])*\"	{ charCount(); yylval=cons(yytext); return(STRING_LITERAL); }
@\"(\\.|[^\\"])*\"			{ charCount(); yylval=cons(yytext); return(AT_STRING_LITERAL); }

	/* standard operators */

"..."			{ charCount(); return(ELLIPSIS); }
">>="			{ charCount(); return(RIGHT_ASSIGN); }
"<<="			{ charCount(); return(LEFT_ASSIGN); }
"+="			{ charCount(); return(ADD_ASSIGN); }
"-="			{ charCount(); return(SUB_ASSIGN); }
"*="			{ charCount(); return(MUL_ASSIGN); }
"/="			{ charCount(); return(DIV_ASSIGN); }
"%="			{ charCount(); return(MOD_ASSIGN); }
"&="			{ charCount(); return(AND_ASSIGN); }
"^="			{ charCount(); return(XOR_ASSIGN); }
"|="			{ charCount(); return(OR_ASSIGN); }
">>"			{ charCount(); return(RIGHT_OP); }
"<<"			{ charCount(); return(LEFT_OP); }
"++"			{ charCount(); return(INC_OP); }
"--"			{ charCount(); return(DEC_OP); }
"->"			{ charCount(); return(PTR_OP); }
"&&"			{ charCount(); return(AND_OP); }
"||"			{ charCount(); return(OR_OP); }
"<="			{ charCount(); return(LE_OP); }
">="			{ charCount(); return(GE_OP); }
"=="			{ charCount(); return(EQ_OP); }
"!="			{ charCount(); return(NE_OP); }
";"				{ charCount(); return(';'); }
("{"|"<%")		{ charCount(); return('{'); }
("}"|"%>")		{ charCount(); return('}'); }
","				{ charCount(); return(','); }
":"				{ charCount(); return(':'); }
"="				{ charCount(); return('='); }
"("				{ charCount(); return('('); }
")"				{ charCount(); return(')'); }
("["|"<:")		{ charCount(); return('['); }
("]"|":>")		{ charCount(); return(']'); }
"."				{ charCount(); return('.'); }
"&"				{ charCount(); return('&'); }
"!"				{ charCount(); return('!'); }
"~"				{ charCount(); return('~'); }
"-"				{ charCount(); return('-'); }
"+"				{ charCount(); return('+'); }
"*"				{ charCount(); return('*'); }
"/"				{ charCount(); return('/'); }
"%"				{ charCount(); return('%'); }
"<"				{ charCount(); return('<'); }
">"				{ charCount(); return('>'); }
"^"				{ charCount(); return('^'); }
"|"				{ charCount(); return('|'); }
"?"				{ charCount(); return('?'); }
 
[\n]			{ line++, column=0; }
[ \t\v\f]		{ charCount(); }
 
.				{ charCount(); error( "bad character" ); }

%%
 
 int yywrap()
 {
	 return(1);
 }
 
 
 void comment(int cxx)
 {
	 char c;
	if(cxx)
		{ // C++ comment
		while ((c = input()) != '\n' && c != EOF)
			/*putchar(c)*/;
		line++;
		return;
		}
	 while ( 1 )
		 {
		 while ( (c = input()) != '*' && c != EOF )
			 { /* eat up text of comment */
			 if(c == '\n')
				 line++;
			 }
		 if ( c == '*' )
			 {
			 while ( (c = input()) == '*' )
				 ;
			 if ( c == '/' )
				 break;    /* found the end */
			 }
		 
		 if ( c == EOF )
			 {
			 error( "EOF in comment" );
			 break;
			 }
		 }
 }
 
 void charCount(void)
 { // cound characters so that we know the column position
	 int i;
	 
	 for (i = 0; yytext[i] != '\0'; i++)
		 if (yytext[i] == '\n')
			 column = 0;
		 else if (yytext[i] == '\t')
			 column += 8 - (column % 8);
		 else
			 column++;
	 
//	 ECHO;
 }

int cons(char *str)
{
	return leaf(CONSTANT, str);
}